.. _basiImplementation:

******************************************************************
:class:`~blitzplusplus::basi::Iterator`---Notes on implementation
******************************************************************


.. py:module:: IndexerImplementations(Specializations).h
   :synopsis: Auto-generates code for Transposer and Indexer


.. highlight:: sh


:class:`~blitzplusplus::basi::Transposer` and :class:`~blitzplusplus::basi::Indexer` are implemented in such a way that a partial template specialization is provided for each possible ``RANK`` (up to 11), and the corresponding code is automatically generated by the `Boost.Preprocessor <http://www.boost.org/doc/libs/1_44_0/libs/preprocessor/doc/index.html>`_ library. This can be seen in :file:`utils/include/details/IndexerImplementations(Specializations).h`. To actually see what code is generated by them, they need to be preprocessed. Issue the following command from the root directory of the distribution::

  g++ -P -E -Iutils/include/ utils/include/details/IndexerImplementations.h | tail -n286

.. highlight:: c++
  :linenothreshold: 10


To store and manipulate the heterogenous collection of slicing indeces like ``0,a,2,a,4,5,a,a,8,a,10`` :func:`above <blitzplusplus::basi::Indexer::index>`, the ``boost::fusion::vector`` class of the `Boost.Fusion <http://www.boost.org/doc/libs/1_44_0/libs/fusion/doc/html/index.html>`_ library is used.

:class:`~blitzplusplus::basi::Iterator` is implemented in terms of the above two helper classes. Each :class:`~blitzplusplus::basi::Iterator` involves a :func:`~blitzplusplus::basi::Transposer::transpose` at its construction, and---if ``RANK`` is larger than ``mpl::size<V>::value``---an :func:`~blitzplusplus::basi::Indexer::index` is invoked at the point of its dereferencing, when the actual slicing occurs.

:class:`~blitzplusplus::basi::Iterator` is a forward iterator, implemented with the help of ``boost::forward_iterator_helper`` from `Boost.Operator <http://www.boost.org/doc/libs/1_44_0/libs/utility/operators.htm#iterator>`_. For this to work, we need to define only 3 operations:
  #. Comparison for equality

  #. Prefix increment

  #. Dereferencing

A special implementation is needed when the size of the compile-time vector ``V`` equals ``RANK`` because in this case actually no slicing takes place, only transposition. For this, as at several other places in the framework, we apply conditional inheritance: :class:`~blitzplusplus::basi::Iterator` inherits from either of two classes (``IteratorBase`` or ``IteratorBaseSpecial``), the decision being made at compile time with the help of ``mpl::if_c``.

The iteration over dummy indeces is implemented with the help of :class:`~cpputils::MultiIndexIterator`.

======================================
A metaprogramming example
======================================

In the following we analyse a metaprogramming example typical for the framework: how the compile-time vector ``0,3,2,6,4,5,1,9,8,7,10`` for the self-transposition :func:`above <blitzplusplus::basi::Transposer::transpose>` is prepared.

This is done by the following snippet in ``utils/include/impl/BlitzArraySliceIterator.tcc``:

.. literalinclude:: examples/multiarrayImplementationMetaProgramming.cc
  :language: c++
  :linenos:

Line 13:
  We are using the `fold <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/fold.html>`_ metaalgorithm from Boost.MPL. It iterates over the :class:`sequence of ordinals <tmptools::Ordinals>` between ``0`` and ``RANK-1``.

Line 14:
  The initial state for the fold algorithm is an empty `compile-time vector of integers <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/vector-c.html>`_ and the `iterator <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/begin.html>`_ pointing to the first element of the compile-time vector ``V``. These two are "zipped" into a `compile-time pair <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/pair.html>`_. At the end, the first element of this pair will hold the result.

Lines 15-25
  express the forward operation of the fold algorithm in the form of a `compile-time lambda expression <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/tutorial/handling-placeholders.html>`_. After each step, the new state will again be a pair composed of

  #. (Lines 15-20:) the vector is `augmented <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/push-back.html>`_ either by the current element in ``V`` pointed to by the iterator (Line 17), or the current ordinal (Line 18), depending on whether ``V`` :class:`~tmptools::numerical_contains` this ordinal.

  #. (Lines 21-24:) the iterator is `advanced <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/next.html>`_ (Line 22) if the same numerical containment criterion is met, otherwise it is left untouched for the same element to be considered again (Line 23).

(Note that in :abbrev:`TMP (template metaprogramming)`, "calling" :class:`~tmptools::numerical_contains`\ ``<V,mpl::_2>`` twice is no waste because the second time no further template instantiations are needed, the compiler will use the ones already instantiated the first time.)

Lines 32-34: the `first element <http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/trivial-metafunctions-summary.html#first>`_ of the resulting pair of the above algorithm is picked. As it is easy to verify, ``TransposerMeta<11,tmptools::Vector<3,6,1,9,7> >::type`` will be an ``mpl::vector_c<int,0,3,2,6,4,5,1,9,8,7,10>``.
  

