.. _basiImplementation:

******************************************************************
:class:`~blitzplusplus::basi::Iterator`---Notes on implementation
******************************************************************


.. py:module:: IndexerImplementations(Specializations).h
   :synopsis: Auto-generates code for Transposer and Indexer


:class:`~blitzplusplus::basi::Transposer` and :class:`~blitzplusplus::basi::Indexer` are implemented in such a way that a partial template specialization is provided for each possible ``RANK`` (up to 11), and the corresponding code is automatically generated by the `Boost.Preprocessor <http://www.boost.org/doc/libs/1_44_0/libs/preprocessor/doc/index.html>`_ library. This can be seen in ``utils/include/details/IndexerImplementations(Specializations).h``. To actually see what code is generated by them, they need to be preprocessed. Issue the following command from the root directory of the distribution:

.. describe:: g++ -P -E -Iutils/include/ utils/include/details/IndexerImplementations.h | tail -n286

To store and manipulate the heterogenous collection of slicing indeces like ``0,a,2,a,4,5,a,a,8,a,10`` :func:`above <blitzplusplus::basi::Indexer::index>`, the ``boost::fusion::vector`` class of the `Boost.Fusion <http://www.boost.org/doc/libs/1_44_0/libs/fusion/doc/html/index.html>`_ library is used.

.. toctree::

  multiarrayImplementationMetaProgramming

:class:`~blitzplusplus::basi::Iterator` is implemented in terms of the above two helper classes. Each :class:`~blitzplusplus::basi::Iterator` involves a :func:`~blitzplusplus::basi::Transposer::transpose` at its construction, and---if ``RANK`` is larger than ``mpl::size<V>::value``---an :func:`~blitzplusplus::basi::Indexer::index` is invoked at the point of its dereferencing, when the actual slicing occurs.

:class:`~blitzplusplus::basi::Iterator` is a forward iterator, implemented with the help of ``boost::forward_iterator_helper`` from `Boost.Operator <http://www.boost.org/doc/libs/1_44_0/libs/utility/operators.htm#iterator>`_. For this to work, we need to define only 3 operations:
  #. Comparison for equality

  #. Prefix increment

  #. Dereferencing

A special implementation is needed when the size of the compile-time vector ``V`` equals ``RANK`` because in this case actually no slicing takes place, only transposition. For this, as at several other places in the framework, we apply conditional inheritance: :class:`~blitzplusplus::basi::Iterator` inherits from either of two classes (``IteratorBase`` or ``IteratorBaseSpecial``), the decision being made at compile time with the help of ``mpl::if_c``.

The iteration over dummy indeces is implemented with the help of :class:`~cpputils::MultiIndexIterator`.


.. todo::

  Implement default versions of :class:`~blitzplusplus::basi::Iterator`\ s for the case when no slicing needs to be performed, that is, when the compile-time vector equals a range<0,RANK-1>. This is, however, not easy, because not a type but some property of the type is the criterion of selection.

.. todo::

  It would be desirable to refine the iterator category according to the `New-Style Iterator <http://www.boost.org/doc/libs/1_44_0/libs/iterator/doc/index.html#new-style-iterators>`_ concepts. A Blitz++.Array is not a container of slices, so :class:`~blitzplusplus::basi::Iterator` is definitely not a standard iterator. It seems rather like a proxy iterator. 


.. todo::

  Where templates are such that they accept only a very restricted set of types, this should be checked for. Examples are :class:`blitzplusplus::basi::Iterator`'s V parameter or :class:`Composite`'s VA. An implementation could be that these types are derived from some tag class and then a static assertion with the help of is_base_of could be performed. An other solution can be Boost.ConceptChecking

