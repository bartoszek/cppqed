// -*- C++ -*-
/*
  Besides being an Adaptive, Stochastic takes into account the possibility of some noise during Evolution, generated by a Randomized.

  In this case the need for taking EnsembleAverage of a certain set of quantities over several such  arises. This set should be condensed into the template parameter T of AverageableTrajectory, on which the requirement is that it support vector-space operations.

  Eg a double or complex for a single c-number quantity, a valarray, or a DensityOperator as in C++QED

  The design is such that Ensemble is recursive: an Ensemble can act as an element in a larger Ensemble.

*/
#ifndef UTILS_INCLUDE_STOCHASTICTRAJECTORY_H_INCLUDED
#define UTILS_INCLUDE_STOCHASTICTRAJECTORY_H_INCLUDED


#include "StochasticTrajectoryFwd.h"

#include "Trajectory.h"
#include "Randomized.h"


#include <boost/ptr_container/ptr_vector.hpp>


namespace trajectory {


//////////////
//
// Averageable
//
//////////////


template<typename T> 
class Averageable : public virtual Trajectory
{
public:
  virtual ~Averageable() {}

  const T toBeAveraged() const {return toBeAveraged_v();}

private:
  virtual const T toBeAveraged_v() const = 0;

};


/////////////
//
// Stochastic
//
/////////////

template<typename A, typename T>
class Stochastic : public Adaptive<A>, public Averageable<T>
{
public:
  typedef Adaptive<A> Base;

  typedef typename Base::Evolved Evolved;

  virtual ~Stochastic() {}

protected:
  typedef randomized::Randomized::Ptr RandomizedPtr;

  Stochastic(A&, typename Evolved::Derivs, double dtInit, 
             double epsRel, double epsAbs, const A& scaleAbs, 
             const evolved::Maker<A>&,
             unsigned long seed,
             bool n,
             const randomized::Maker&);

  Stochastic(A&, typename Evolved::Derivs, double dtInit,
             const A& scaleAbs, const ParsStochastic&,
             const evolved::Maker<A>&,
             const randomized::Maker&);

  const RandomizedPtr getRandomized() const {return randomized_;}
  bool                noise        () const {return isNoisy_   ;}

  std::ostream& displayParameters_v(std::ostream&) const;
  
#ifndef   DO_NOT_USE_BOOST_SERIALIZATION
  typedef typename Base::iarchive iarchive;
  typedef typename Base::oarchive oarchive;
  iarchive&  readState_v(iarchive& iar)       {return Base:: readState_v(iar) & *randomized_;}
  oarchive& writeState_v(oarchive& oar) const {return Base::writeState_v(oar) & *randomized_;}
#endif // DO_NOT_USE_BOOST_SERIALIZATION

private:
  const unsigned long seed_ ;
  const bool          isNoisy_;

  const RandomizedPtr randomized_;

};


///////////
//
// Ensemble
//
///////////


namespace details {

template<typename T>
class EnsembleBase {};


template<typename T>
class EnsembleBase<T&>
{
public:
  typedef T& TBA_Type;

  const TBA_Type getInitializedTBA() const {return getInitializedTBA_v();}

  virtual ~EnsembleBase() {}

private:
  virtual const TBA_Type getInitializedTBA_v() const = 0;
  
};


}

/*
  
  The implicit interface:
  
      reference case : T_ELEM must be addable to T via an addTo function.

  non-reference case : T must be constructible from a T_ELEM

*/


template<typename T, typename T_ELEM>
class Ensemble : public Averageable<T>, public details::EnsembleBase<T>
{
public:
  typedef Averageable<T     > Base;
  typedef Averageable<T_ELEM> Elem;

  typedef T TBA_Type;

  const TBA_Type averageInRange(size_t begin, size_t n) const;
  // Averages only in a range begin..begin+n-1. Earlier, this was called toBeAveraged, too, but it is not good to redefine an inherited non-virtual function.

  virtual ~Ensemble() {}

  typedef boost::ptr_vector<Elem> Impl;
  // We use a vector in order that individual trajectories are addressed more easily.

  const Impl& getTrajs() const {return trajs_;}

protected:
  typedef std::auto_ptr<Impl> Ptr;
  
  Ensemble(Ptr trajs, bool log) : trajs_(trajs), log_(log) {}

  #ifndef   DO_NOT_USE_BOOST_SERIALIZATION
  typedef typename Base::iarchive iarchive;
  typedef typename Base::oarchive oarchive;
  iarchive&  readState_v(iarchive& iar)       {for_each(trajs_,bind(&Elem:: readState,_1,boost::ref(iar))); return iar;}
  oarchive& writeState_v(oarchive& oar) const {for_each(trajs_,bind(&Elem::writeState,_1,boost::ref(oar))); return oar;}
  #endif // DO_NOT_USE_BOOST_SERIALIZATION

private:
  void evolve_v(double deltaT) const;

  double getTime_v() const {return trajs_.begin()->getTime();}

  std::ostream& displayParameters_v(std::ostream&) const;

  double getDtDid_v() const;
  // An average of getDtDid()-s from individual trajectories.

  const TBA_Type toBeAveraged_v() const {return averageInRange(0,trajs_.size());}

  const Impl trajs_;

  const bool log_;

};



// Implementation of the traits class for the most commonly used case:

template<typename T, typename T_ELEM>
class EnsembleTraits
{
public:
  typedef Ensemble<T,T_ELEM> ET;

  typedef typename ET::Elem     Elem    ;
  typedef typename ET::Impl     Impl    ;
  typedef typename ET::TBA_Type TBA_Type;

  static const TBA_Type averageInRange(typename Impl::const_iterator, typename Impl::const_iterator, const ET&);

};


} // trajectory


#endif // UTILS_INCLUDE_STOCHASTICTRAJECTORY_H_INCLUDED
